use crate::ast::*;
use crate::error::UserError;
use lalrpop_util::ParseError;

grammar;

extern {
  type Error = UserError;
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
    _
}

WithSource<T>: Sourced<T> = {
  @L T => (<>)
}

Comma<T>: Vec<T> = {
  <mut v: (<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
}


//字面量
NullLiteral_: AstLiteral_ = {
    "null" => AstLiteral_::Null
}
BoolLiteral_: AstLiteral_ = {
  "true" =>  AstLiteral_::Bool(true),
  "false" => AstLiteral_::Bool(false)
}
CharLiteral_: AstLiteral_ = {
  <r##"'[^\\']'"##> => AstLiteral_::Char({
    let char = (<>).chars().nth(1).unwrap(); 
    assert!(char.is_ascii());
    char as u8
  }),
  <r##"'\\[tnr\\'0]'"##> => AstLiteral_::Char({
    let to_escape = (<>).chars().nth(2).unwrap(); 
    match to_escape {
      't' => b'\t',
      'n' => b'\n',
      'r' => b'\r',
      '\\' => b'\\',
      '\'' => b'\'',
      '0' => b'\0',
      _ => unreachable!()
    }
  })
}
IntLiteral_: AstLiteral_ = {
  <r##"0x[0-9a-fA-F]+"##> =>? {
    let to_parse = &(<>)[2..];
    i32::from_str_radix(to_parse, 16)
      .map(AstLiteral_::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(err, <>.to_owned())
      })
  },
  <r##"0b[01]+"##> =>? {
    let to_parse = &(<>)[2..];
    i32::from_str_radix(to_parse, 2)
      .map(AstLiteral_::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(err, <>.to_owned())
      })
  },
  <r##"0o[0-7]+"##> =>? {
    let to_parse = &(<>)[2..];
    i32::from_str_radix(to_parse, 8)
      .map(AstLiteral_::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(err, <>.to_owned())
      })
  },
  <r##"[+-]?[0-9]+"##> =>? {
    let to_parse = &<>;
    i32::from_str_radix(to_parse, 10)
      .map(AstLiteral_::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(err, <>.to_owned())
      })
  }
}
FloatLiteral_: AstLiteral_ = {
  <r##"[\-\+]?[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"##> =>? {
    <>.parse::<f32>()
      .map(AstLiteral_::Float)
      .map_err(|err| ParseError::User {
        error: UserError::ParseFloatError(err, <>.to_owned())
      })
  }
}
StringLiteral_: AstLiteral_ = {
  <r##""([^"\\]|\\[tnr\\0"])*""##> => AstLiteral_::String({
    let mut chars = (<>).chars();
    let mut string = String::new();
    chars.next();
    while let Some(c) = chars.next() {
      match c {
        '\\' => {
          let to_escape = chars.next().unwrap();
          match to_escape {
            't' => string.push('\t'),
            'n' => string.push('\n'),
            'r' => string.push('\r'),
            '\\' => string.push('\\'),
            '"' => string.push('"'),
            '0' => string.push('\0'),
            _ => unreachable!()
          }
        },
        '"' => break,
        _ => string.push(c)
      }
    }
    string
  })
}
Literal_: AstLiteral_ = {
  NullLiteral_,
  BoolLiteral_,
  CharLiteral_,
  IntLiteral_ ,
  FloatLiteral_ ,
  StringLiteral_ ,
  "{" <Comma<Literal>> "}" => AstLiteral_::List(<>),
}
pub NullLiteral = WithSource<NullLiteral_>;
pub BoolLiteral = WithSource<BoolLiteral_>;
pub CharLiteral = WithSource<CharLiteral_>;
pub IntLiteral = WithSource<IntLiteral_>;
pub FloatLiteral = WithSource<FloatLiteral_>;
pub StringLiteral = WithSource<StringLiteral_>;
pub Literal = WithSource<Literal_>;


//基本类型
PrimType_: AstPrimType_ = {
  "void" => AstPrimType_::Void,
  "bool" => AstPrimType_::Bool,
  "char" => AstPrimType_::Char,
  "int" => AstPrimType_::Int,
  "float" => AstPrimType_::Float,
}
PrimType = WithSource<PrimType_>;
//类型
Type_: AstType_ = {
  <PrimType> => AstType_::Prim(<>),
}
pub Type = WithSource<Type_>;

Ident: String = r##"[a-zA-Z_][a-zA-Z_0-9]*"## => <>.to_owned();

LValue_: AstLValue_ = {
  Ident => AstLValue_::Ident(<>),
  "*" <Expr> => AstLValue_::Deref(Box::new(<>)),
  <Ident> <("[" <Expr> "]")+> => AstLValue_::Idx(<>),
}
pub LValue = WithSource<LValue_>;

Expr_: AstExpr_ = {
  PrimExpr => AstExpr_::Prim(<>),
}
pub Expr = WithSource<Expr_>;

PrimExpr_: AstPrimExpr_ = {
  LValue => AstPrimExpr_::LVal(<>),
  Literal => AstPrimExpr_::Literal(<>),
  "(" <Expr> ")" => AstPrimExpr_::Paren(Box::new(<>)),
  <Ident> "(" <WithSource<Comma<Expr>>> ")" =>  AstPrimExpr_::Call(<>),
}
pub PrimExpr = WithSource<PrimExpr_>;




