use ast::{self, Sourced};
use crate::error::UserError;
use lalrpop_util::ParseError;

grammar;

extern {
  type Error = UserError<'input>;
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
    _
}

WithSource<T>: Sourced<T> = {
  @L T => (<>)
}

Comma<T>: Vec<T> = {
  <mut v: (<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
}

Ident = WithSource<r##"[a-zA-Z_][a-zA-Z_0-9]*"##>;

IntLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"0x[0-9a-fA-F]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 16)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0b[01]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 2)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0o[0-7]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 8)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"[\+\-]?[0-9]+"##> =>? {
    i32::from_str_radix(to_parse, 10)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  }
}
FloatLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"[\-\+]?[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"##> =>? {
    to_parse.parse::<f32>()
      .map(ast::Literal::Float)
      .map_err(|err| ParseError::User {
        error: UserError::ParseFloatError(loc, err, to_parse)
      })
  }
}

BoolLiteral_: ast::Literal = {
  "true" => ast::Literal::Bool(true),
  "false" => ast::Literal::Bool(false)
}

Literal_: ast::Literal = {
  BoolLiteral_,
  IntLiteral_ ,
  FloatLiteral_ ,
  "{" <Comma<Literal>> "}" => ast::Literal::List(<>),
}
pub Literal = WithSource<Literal_>;


//基本类型
PrimType_: ast::PrimType = {
  "void" => ast::PrimType::Void,
  "bool" => ast::PrimType::Bool,
  "int" => ast::PrimType::Int,
  "float" => ast::PrimType::Float,
}
pub PrimType = WithSource<PrimType_>;


//LValue_: AstLValue_ = {
//  Ident => AstLValue_::Ident(<>),
//  Ident ("["<Expr>"]")+ => AstLValue_::Idx(<>),
//}
//
//pub LValue = WithSource<LValue_>;
//
//PrimExpr_: AstPrimExpr_ = {
//  LValue => AstPrimExpr_::LVal(<>),
//  Literal => AstPrimExpr_::Literal(<>),
//  "(" <Expr> ")" => AstPrimExpr_::Paren(Box::new(<>)),
//  <Ident> "(" <WithSource<Comma<Expr>>> ")" =>  AstPrimExpr_::Call(<>),
//}
//pub PrimExpr = WithSource<PrimExpr_>;
//
//LogicalOrOp_: AstBinaryOp_ = "||" => AstBinaryOp_::LogicalOr;
//LogicalOrOp = WithSource<LogicalOrOp_>;
//LogicalAndOp_: AstBinaryOp_ = "&&" => AstBinaryOp_::LogicalAnd;
//LogicalAndOp = WithSource<LogicalAndOp_>;
//BitOrOp_: AstBinaryOp_ = "|" => AstBinaryOp_::BitOr;
//BitOrOp = WithSource<BitOrOp_>;
//BitXorOp_: AstBinaryOp_ = "^" => AstBinaryOp_::BitXor;
//BitXorOp = WithSource<BitXorOp_>;
//BitAndOp_: AstBinaryOp_ = "&" => AstBinaryOp_::BitAnd;
//BitAndOp = WithSource<BitAndOp_>;
//EqOp_: AstBinaryOp_ = "==" => AstBinaryOp_::Eq;
//EqOp = WithSource<EqOp_>;
//NeOp_: AstBinaryOp_ = "!=" => AstBinaryOp_::Ne;
//NeOp = WithSource<NeOp_>;
//LtOp_: AstBinaryOp_ = "<" => AstBinaryOp_::Lt;
//LtOp = WithSource<LtOp_>;
//GtOp_: AstBinaryOp_ = ">" => AstBinaryOp_::Gt;
//GtOp = WithSource<GtOp_>;
//LeOp_: AstBinaryOp_ = "<=" => AstBinaryOp_::Le;
//LeOp = WithSource<LeOp_>;
//GeOp_: AstBinaryOp_ = ">=" => AstBinaryOp_::Ge;
//GeOp = WithSource<GeOp_>;
//ShlOp_: AstBinaryOp_ = "<<" => AstBinaryOp_::Shl;
//ShlOp = WithSource<ShlOp_>;
//ShrOp_: AstBinaryOp_ = ">>" => AstBinaryOp_::Shr;
//ShrOp = WithSource<ShrOp_>;
//AddOp_: AstBinaryOp_ = "+" => AstBinaryOp_::Add;
//AddOp = WithSource<AddOp_>;
//SubOp_: AstBinaryOp_ = "-" => AstBinaryOp_::Sub;
//SubOp = WithSource<SubOp_>;
//MulOp_: AstBinaryOp_ = "*" => AstBinaryOp_::Mul;
//MulOp = WithSource<MulOp_>;
//DivOp_: AstBinaryOp_ = "/" => AstBinaryOp_::Div;
//DivOp = WithSource<DivOp_>;
//ModOp_: AstBinaryOp_ = "%" => AstBinaryOp_::Mod;
//ModOp = WithSource<ModOp_>;
//
//PosOp_: AstUnaryOp_ = "+" => AstUnaryOp_::Pos;
//PosOp = WithSource<PosOp_>;
//NegOp_: AstUnaryOp_ = "-" => AstUnaryOp_::Neg;
//NegOp = WithSource<NegOp_>;
//NotOp_: AstUnaryOp_ = "!" => AstUnaryOp_::Not;
//NotOp = WithSource<NotOp_>;
//BitNotOp_: AstUnaryOp_ = "~" => AstUnaryOp_::BitNot;
//BitNotOp = WithSource<BitNotOp_>;
//
//Tier<Op, NextTier>: AstExpr = {
//  <loc: @L> <lhs: Tier<Op, NextTier>> <op:Op> <rhs: NextTier> => (loc, AstExpr_::Binary(
//    (
//      loc, 
//      AstBinary_ {
//        lhs: Box::new(lhs),
//        op: op,
//        rhs: Box::new(rhs)
//      }
//    )
//  )) ,
//  NextTier,
//}
//
//pub Expr = LogicalOr;
//LogicalOr = Tier<LogicalOrOp, LogicalAnd>;
//LogicalAnd = Tier<LogicalAndOp, BitOr>;
//BitOr = Tier<BitOrOp, BitXor>;
//BitXor = Tier<BitXorOp, BitAnd>;
//BitAnd = Tier<BitAndOp, EqNe>;
//EqNeOp: AstBinaryOp = {
//  EqOp,
//  NeOp
//}
//EqNe = Tier<EqNeOp, Relational>;
//CmpOp : AstBinaryOp = {
//  LtOp,
//  GtOp,
//  LeOp,
//  GeOp
//}
//Relational: AstExpr = {
//  //Shift,
//  //<loc: @L> <lhs: Expr> <op: CmpOp> <rhs: Expr> => (loc, AstExpr_::Binary(
//  //  (
//  //    loc, 
//  //    AstBinary_ {
//  //      lhs: Box::new(lhs),
//  //      op: op,
//  //      rhs: Box::new(rhs)
//  //    }
//  //  )
//  //))
//}
