use ast::{self, Sourced};
use crate::error::UserError;
use lalrpop_util::ParseError;

grammar;

extern {
  type Error = UserError<'input>;
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
    _
}

WithSource<T>: Sourced<T> = {
  @L T => (<>)
}

Comma<T>: Vec<T> = {
  <mut v: (<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
}

Ident = WithSource<r##"[a-zA-Z_][a-zA-Z_0-9]*"##>;

IntLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"0x[0-9a-fA-F]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 16)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0b[01]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 2)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0o[0-7]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 8)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"[\+\-]?[0-9]+"##> =>? {
    i32::from_str_radix(to_parse, 10)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  }
}
FloatLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"[\-\+]?[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"##> =>? {
    to_parse.parse::<f32>()
      .map(ast::Literal::Float)
      .map_err(|err| ParseError::User {
        error: UserError::ParseFloatError(loc, err, to_parse)
      })
  }
}

BoolLiteral_: ast::Literal = {
  "true" => ast::Literal::Bool(true),
  "false" => ast::Literal::Bool(false)
}

Literal_: ast::Literal = {
  BoolLiteral_,
  IntLiteral_ ,
  FloatLiteral_ ,
  "{" <Comma<Literal>> "}" => ast::Literal::List(<>),
}
pub Literal = WithSource<Literal_>;


//基本类型
PrimType_: ast::PrimType = {
  "void" => ast::PrimType::Void,
  "bool" => ast::PrimType::Bool,
  "int" => ast::PrimType::Int,
  "float" => ast::PrimType::Float,
}
pub PrimType = WithSource<PrimType_>;


LValue_: ast::LValue = {
  Ident => ast::LValue::Ident(<>),
  Ident ("["<Expr>"]")+ => ast::LValue::Idx(<>),
}
pub LValue = WithSource<LValue_>;
 
PrimExpr_: ast::PrimExpr = {
  LValue => ast::PrimExpr::LValue(<>),
  Literal => ast::PrimExpr::Literal(<>),
  "(" <Expr> ")" => ast::PrimExpr::Paren(Box::new(<>)),
  <Ident> "(" <WithSource<Comma<Expr>>> ")" =>  ast::PrimExpr::Call(<>),
}
pub PrimExpr = WithSource<PrimExpr_>;

LogicalOrOp_: ast::BinaryOp = "||" => ast::BinaryOp::LogicalOr;
LogicalOrOp = WithSource<LogicalOrOp_>;
LogicalAndOp_: ast::BinaryOp = "&&" => ast::BinaryOp::LogicalAnd;
LogicalAndOp = WithSource<LogicalAndOp_>;
BitOrOp_: ast::BinaryOp = "|" => ast::BinaryOp::BitOr;
BitOrOp = WithSource<BitOrOp_>;
BitXorOp_: ast::BinaryOp = "^" => ast::BinaryOp::BitXor;
BitXorOp = WithSource<BitXorOp_>;
BitAndOp_: ast::BinaryOp = "&" => ast::BinaryOp::BitAnd;
BitAndOp = WithSource<BitAndOp_>;
EqOp_: ast::BinaryOp = "==" => ast::BinaryOp::Eq;
EqOp = WithSource<EqOp_>;
NeOp_: ast::BinaryOp = "!=" => ast::BinaryOp::Ne;
NeOp = WithSource<NeOp_>;
LtOp_: ast::BinaryOp = "<" => ast::BinaryOp::Lt;
LtOp = WithSource<LtOp_>;
GtOp_: ast::BinaryOp = ">" => ast::BinaryOp::Gt;
GtOp = WithSource<GtOp_>;
LeOp_: ast::BinaryOp = "<=" => ast::BinaryOp::Le;
LeOp = WithSource<LeOp_>;
GeOp_: ast::BinaryOp = ">=" => ast::BinaryOp::Ge;
GeOp = WithSource<GeOp_>;
ShlOp_: ast::BinaryOp = "<<" => ast::BinaryOp::Shl;
ShlOp = WithSource<ShlOp_>;
ShrOp_: ast::BinaryOp = ">>" => ast::BinaryOp::Shr;
ShrOp = WithSource<ShrOp_>;
AddOp_: ast::BinaryOp = "+" => ast::BinaryOp::Add;
AddOp = WithSource<AddOp_>;
SubOp_: ast::BinaryOp = "-" => ast::BinaryOp::Sub;
SubOp = WithSource<SubOp_>;
MulOp_: ast::BinaryOp = "*" => ast::BinaryOp::Mul;
MulOp = WithSource<MulOp_>;
DivOp_: ast::BinaryOp = "/" => ast::BinaryOp::Div;
DivOp = WithSource<DivOp_>;
ModOp_: ast::BinaryOp = "%" => ast::BinaryOp::Mod;
ModOp = WithSource<ModOp_>;

PosOp_: ast:UnaryOp = "+" => ast:UnaryOp::Pos;
PosOp = WithSource<PosOp_>;
NegOp_: ast:UnaryOp = "-" => ast:UnaryOp::Neg;
NegOp = WithSource<NegOp_>;
NotOp_: ast:UnaryOp = "!" => ast:UnaryOp::Not;
NotOp = WithSource<NotOp_>;
BitNotOp_: ast:UnaryOp = "~" => ast:UnaryOp::BitNot;
BitNotOp = WithSource<BitNotOp_>;

Tier<Op, NextTier>: ast::Expr = {
  <lhs: Sourced<Tier<Op, NextTier>>> <op:Op> <rhs: Sourced<NextTier>> => (loc, AstExpr_::Binary(
    (
      loc, 
      AstBinary_ {
        lhs: Box::new(lhs),
        op: op,
        rhs: Box::new(rhs)
      }
    )
  )) ,
  NextTier,
}
//
//pub Expr = LogicalOr;
//LogicalOr = Tier<LogicalOrOp, LogicalAnd>;
//LogicalAnd = Tier<LogicalAndOp, BitOr>;
//BitOr = Tier<BitOrOp, BitXor>;
//BitXor = Tier<BitXorOp, BitAnd>;
//BitAnd = Tier<BitAndOp, EqNe>;
//EqNeOp: AstBinaryOp = {
//  EqOp,
//  NeOp
//}
//EqNe = Tier<EqNeOp, Relational>;
//CmpOp : AstBinaryOp = {
//  LtOp,
//  GtOp,
//  LeOp,
//  GeOp
//}
//Relational: AstExpr = {
//  //Shift,
//  //<loc: @L> <lhs: Expr> <op: CmpOp> <rhs: Expr> => (loc, AstExpr_::Binary(
//  //  (
//  //    loc, 
//  //    AstBinary_ {
//  //      lhs: Box::new(lhs),
//  //      op: op,
//  //      rhs: Box::new(rhs)
//  //    }
//  //  )
//  //))
//}
