use ast::{self, Sourced};
use crate::error::UserError;
use lalrpop_util::ParseError;

grammar;

extern {
  type Error = UserError<'input>;
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
    _
}

WithSource<T>: Sourced<T> = {
  @L T => (<>)
}

Comma<T>: Vec<T> = {
  <mut v: (<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
}

Ident = WithSource<r##"[a-zA-Z_][a-zA-Z_0-9]*"##>;

IntLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"0x[0-9a-fA-F]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 16)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0b[01]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 2)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"0o[0-7]+"##> =>? {
    i32::from_str_radix(&to_parse[2..], 8)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  },
  <loc: @L> <to_parse: r##"[\+\-]?[0-9]+"##> =>? {
    i32::from_str_radix(to_parse, 10)
      .map(ast::Literal::Int)
      .map_err(|err| ParseError::User {
        error: UserError::ParseIntegerError(loc, err, to_parse)
      })
  }
}
FloatLiteral_: ast::Literal = {
  <loc: @L> <to_parse: r##"[\-\+]?[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"##> =>? {
    to_parse.parse::<f32>()
      .map(ast::Literal::Float)
      .map_err(|err| ParseError::User {
        error: UserError::ParseFloatError(loc, err, to_parse)
      })
  }
}

BoolLiteral_: ast::Literal = {
  "true" => ast::Literal::Bool(true),
  "false" => ast::Literal::Bool(false)
}

Literal_: ast::Literal = {
  BoolLiteral_,
  IntLiteral_ ,
  FloatLiteral_ ,
  "{" <Comma<Literal>> "}" => ast::Literal::List(<>),
}
pub Literal = WithSource<Literal_>;


//基本类型
PrimType_: ast::PrimType = {
  "void" => ast::PrimType::Void,
  "bool" => ast::PrimType::Bool,
  "int" => ast::PrimType::Int,
  "float" => ast::PrimType::Float,
}
pub PrimType = WithSource<PrimType_>;



LogicalOrOp_: ast::BinaryOp = "||" => ast::BinaryOp::LogicalOr;
LogicalOrOp = WithSource<LogicalOrOp_>;
LogicalAndOp_: ast::BinaryOp = "&&" => ast::BinaryOp::LogicalAnd;
LogicalAndOp = WithSource<LogicalAndOp_>;
BitOrOp_: ast::BinaryOp = "|" => ast::BinaryOp::BitOr;
BitOrOp = WithSource<BitOrOp_>;
BitXorOp_: ast::BinaryOp = "^" => ast::BinaryOp::BitXor;
BitXorOp = WithSource<BitXorOp_>;
BitAndOp_: ast::BinaryOp = "&" => ast::BinaryOp::BitAnd;
BitAndOp = WithSource<BitAndOp_>;
EqOp_: ast::BinaryOp = "==" => ast::BinaryOp::Eq;
EqOp = WithSource<EqOp_>;
NeOp_: ast::BinaryOp = "!=" => ast::BinaryOp::Ne;
NeOp = WithSource<NeOp_>;
LtOp_: ast::BinaryOp = "<" => ast::BinaryOp::Lt;
LtOp = WithSource<LtOp_>;
GtOp_: ast::BinaryOp = ">" => ast::BinaryOp::Gt;
GtOp = WithSource<GtOp_>;
LeOp_: ast::BinaryOp = "<=" => ast::BinaryOp::Le;
LeOp = WithSource<LeOp_>;
GeOp_: ast::BinaryOp = ">=" => ast::BinaryOp::Ge;
GeOp = WithSource<GeOp_>;
ShlOp_: ast::BinaryOp = "<<" => ast::BinaryOp::Shl;
ShlOp = WithSource<ShlOp_>;
ShrOp_: ast::BinaryOp = ">>" => ast::BinaryOp::Shr;
ShrOp = WithSource<ShrOp_>;
AddOp_: ast::BinaryOp = "+" => ast::BinaryOp::Add;
AddOp = WithSource<AddOp_>;
SubOp_: ast::BinaryOp = "-" => ast::BinaryOp::Sub;
SubOp = WithSource<SubOp_>;
MulOp_: ast::BinaryOp = "*" => ast::BinaryOp::Mul;
MulOp = WithSource<MulOp_>;
DivOp_: ast::BinaryOp = "/" => ast::BinaryOp::Div;
DivOp = WithSource<DivOp_>;
ModOp_: ast::BinaryOp = "%" => ast::BinaryOp::Mod;
ModOp = WithSource<ModOp_>;

PosOp_: ast::UnaryOp = "+" => ast::UnaryOp::Pos;
PosOp = WithSource<PosOp_>;
NegOp_: ast::UnaryOp = "-" => ast::UnaryOp::Neg;
NegOp = WithSource<NegOp_>;
NotOp_: ast::UnaryOp = "!" => ast::UnaryOp::Not;
NotOp = WithSource<NotOp_>;
BitNotOp_: ast::UnaryOp = "~" => ast::UnaryOp::BitNot;
BitNotOp = WithSource<BitNotOp_>;
UnaryOp = { PosOp, NegOp, NotOp, BitNotOp };

EqNeOp = { EqOp, NeOp };
CmpOp = { LtOp, GtOp, LeOp, GeOp };
ShiftOp = { ShlOp, ShrOp };
AddSubOp = { AddOp, SubOp };
MulDivModOp = { MulOp, DivOp, ModOp };

Tier<Op, NextTier>: ast::Expr<'input> = {
  <loc: @L> <lhs: WithSource<Tier<Op, NextTier>>> <op:Op> <rhs: WithSource<NextTier>> => ast::Expr::Binary(
    (
      loc,
      ast::Binary { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
    )
  ),
  NextTier,
}

pub Expr = WithSource<LogicalOr>;
LogicalOr = Tier<LogicalOrOp, LogicalAnd>;
LogicalAnd = Tier<LogicalAndOp, BitOr>;
BitOr = Tier<BitOrOp, BitXor>;
BitXor = Tier<BitXorOp, BitAnd>;
BitAnd = Tier<BitAndOp, EqNe>;
EqNe = Tier<EqNeOp, Relational>;
Relational = Tier<CmpOp, Shift>;
Shift = Tier<ShiftOp, AddSub>;
AddSub = Tier<AddSubOp, MulDivMod>;
MulDivMod = Tier<MulDivModOp, Unary>;

Unary: ast::Expr<'input> = {
  <loc: @L> <op:UnaryOp> <rhs: WithSource<Unary>> => ast::Expr::Unary(
    (
      loc,
      ast::Unary { op, rhs: Box::new(rhs) }
    )
  ),
  PrimExpr => ast::Expr::Prim(<>)
}


LValue_: ast::LValue<'input> = {
  Ident => ast::LValue::Ident(<>),
  Ident ("["<Expr>"]")+ => ast::LValue::Idx(<>),
}
pub LValue = WithSource<LValue_>;
 
PrimExpr_: ast::PrimExpr<'input> = {
  LValue => ast::PrimExpr::LValue(<>),
  Literal => ast::PrimExpr::Literal(<>),
  "(" <Expr> ")" => ast::PrimExpr::Paren(Box::new(<>)),
  <Ident> "(" <WithSource<Comma<Expr>>> ")" =>  ast::PrimExpr::Call(<>),
}
PrimExpr = WithSource<PrimExpr_>;
